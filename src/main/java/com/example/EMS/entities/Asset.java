package com.example.EMS.entities;

import com.fasterxml.jackson.annotation.JsonIdentityInfo;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.ObjectIdGenerators;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@Entity
@Table(name = "asset")
@JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class,property = "assetId")
public class Asset {
    @Id
    @GeneratedValue(strategy= GenerationType.IDENTITY)//mysql support IDENTITY and increment value by 1

    @Column(name="id",updatable = false)
    private Integer assetId;
    @Column(nullable = false)
    //@Range(min = 1,message = "Numbers of computer must be greater than 1")
    private String assetName;
    @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)//The access property with a value of "writeonly" in a JSON schema definition is used to indicate that a property should be writable by the client, but not readable. This means that the property can be included in a JSON request to update the corresponding record in the database, but it will not be returned in the response from the server.In Spring Boot, the @JsonProperty annotation is used to specify how a field in a Java object should be serialized or deserialized when it is converted   to or from JSON. The "access" attribute of the annotation can be used to specify whether the field should be included in the JSON when the object is serialized, or whether it should be set when the object is deserialized.If the "access" attribute is set to JsonProperty.Access.WRITE_ONLY, it means that the field will be included in the JSON when the object is serialized, but will not be set when the object is deserialized. This can be useful in cases where the value of the field should not be provided by external clients, but should be generated by the application. For example, if a field contains a password, it may be set as write-only to prevent the password from being deserialized and potentially exposed.
    @ManyToOne
   // @NotNull(message = "Organization id is missing")
    @JoinColumn(name = "fk_org_id")//one column is added when using @ManytoOne so setting column name otherwise default name it will take
    private  Organization orgId;
}




































/**@JsonIdentityInfo is a Jackson annotation in Java used to handle circular references between objects during
 * serialization and deserialization of JSON data. In certain cases, such as when there is a bidirectional relationship
 * between objects or when an object contains references to itself, the default serialization and deserialization
 * process may lead to infinite loops or redundant data.
 *
 * ***https://thorben-janssen.com/5-things-you-need-to-know-when-using-hibernate-with-mysql/#1_Mappings_Primary_Keys
 * @GeneratedValue( strategy= GenerationType.IDENTITY)//MYSQL support GenerationType. IDENTITY and gives more efficient performance. If we use this single line then no extra sequence table will be created in mysqldb and value will be incremented by 1
 *
 * if we use @GeneratedValue( strategy= GenerationType.AUTO)//then value is not increment by 1 in mysqldb
 *
 * Mysql does not support this @SequenceGenerator it does not increment by 2 it always increments by 1
 *  @GeneratedValue( name="gen1",strategy= GenerationType.SEQUENCE)//ORACLE SUPPORT SEQUENCE.IF we use this then extra table will be created in mysql db ie.extra query will be generated to get primary key value.and value will be incremented by 2 BUT IN MYSQL ualue is incrementing by 1
 *  @SequenceGenerator(name = "gen1",sequenceName = "asset_gen1",initialValue = 1,allocationSize = 2)//allocationSize is increment by 2
 * */