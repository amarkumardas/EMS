package com.example.EMS.entities;

import com.fasterxml.jackson.annotation.JsonIdentityInfo;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.ObjectIdGenerators;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@Getter
@Setter
@Entity
@JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class,property = "empId")
public class Employee implements UserDetails{
    @Id
    @GeneratedValue( strategy= GenerationType.IDENTITY)

    @Column(name="id",updatable = false)
    private Integer empId;
    @Column(nullable = false)
   // @NotBlank(message = "Name is required")
    private String name;
    @Column(nullable = false,unique = true)
   // @Email(message = "Invalid email")
   // @NotEmpty(message = "Email cannot be empty")
    private String email;
    @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)//The access property with a value of "writeonly" in a JSON schema definition is used to indicate that a property should be writable by the client, but not readable. This means that the property can be included in a JSON request to update the corresponding record in the database, but it will not be returned in the response from the server.In Spring Boot, the @JsonProperty annotation is used to specify how a field in a Java object should be serialized or deserialized when it is converted   to or from JSON. The "access" attribute of the annotation can be used to specify whether the field should be included in the JSON when the object is serialized, or whether it should be set when the object is deserialized.If the "access" attribute is set to JsonProperty.Access.WRITE_ONLY, it means that the field will be included in the JSON when the object is serialized, but will not be set when the object is deserialized. This can be useful in cases where the value of the field should not be provided by external clients, but should be generated by the application. For example, if a field contains a password, it may be set as write-only to prevent the password from being deserialized and potentially exposed.
    @Column(nullable = false)
   // @NotBlank(message = "Password is mandatory")
  //  @Size(min=3,max = 256,message = "Password must be minimum of 3 characters and maximum of 256 characters")
    private String password;

   // @NotNull(message = "Organization id is missing")
   @JsonProperty(access = JsonProperty.Access.WRITE_ONLY)//The access property with a value of "writeonly" in a JSON schema definition is used to indicate that a property should be writable by the client, but not readable. This means that the property can be included in a JSON request to update the corresponding record in the database, but it will not be returned in the response from the server.In Spring Boot, the @JsonProperty annotation is used to specify how a field in a Java object should be serialized or deserialized when it is converted   to or from JSON. The "access" attribute of the annotation can be used to specify whether the field should be included in the JSON when the object is serialized, or whether it should be set when the object is deserialized.If the "access" attribute is set to JsonProperty.Access.WRITE_ONLY, it means that the field will be included in the JSON when the object is serialized, but will not be set when the object is deserialized. This can be useful in cases where the value of the field should not be provided by external clients, but should be generated by the application. For example, if a field contains a password, it may be set as write-only to prevent the password from being deserialized and potentially exposed.
   @ManyToOne
    @JoinColumn(name = "fk_org_id",nullable = false)//one column is added when using @ManytoOne so setting column name otherwise default name it will take
    private  Organization orgId;

   @JoinTable(name="role_assign",joinColumns = @JoinColumn(name="emp_id"),inverseJoinColumns = @JoinColumn(name="role_id"))//this table is automatically created when using @ManyToMany Annotation so modifying that table

    @JsonIgnore//to avoid both serialization and deserialization because automatically role is added
    @ManyToMany(cascade=CascadeType.ALL,fetch = FetchType.EAGER)//by default fetchtype is LAZY so making it eager otherwise during authentication error:failed to lazily initialize a collection of role
    private Set<Roles> roles;


   @JsonIgnore
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {//getting all roles of user
        List<GrantedAuthority> grantedAuthorities=this.roles.stream().map((role -> new SimpleGrantedAuthority(role.getRoleName()))).collect(Collectors.toList());
        return grantedAuthorities;
    }
    @JsonIgnore
    @Override
    public String getUsername() {
        return this.email;
    }

    @JsonIgnore
    @Override
    public String getPassword(){
       return this.password;
    }
    @JsonIgnore
    @Override
    public boolean isAccountNonExpired() {
        return true;
    }
    @JsonIgnore
    @Override
    public boolean isAccountNonLocked() {
        return true;
    }
    @JsonIgnore
    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }
    @JsonIgnore
    @Override
    public boolean isEnabled() {
        return true;
    }
}


























/**@JsonIdentityInfo is a Jackson annotation in Java used to handle circular references between objects during
 * serialization and deserialization of JSON data. In certain cases, such as when there is a bidirectional relationship
 * between objects or when an object contains references to itself, the default serialization and deserialization
 * process may lead to infinite loops or redundant data.
 *
 * @JsonIgnore is an annotation provided by Jackson, a popular JSON library used in Spring Boot applications.
 * This annotation is used to indicate that a property in a Java class should be ignored when serializing or
 * deserializing JSON data.
 *When this annotation is used on a field or getter method of a Java class, Jackson will skip that field or method
 *  when creating a JSON representation of the object or reading JSON data into the object.
 *
 * if a field in a Java class is annotated with @JsonIgnore, it will be excluded from both serialization and deserialization.
 * That means if you set the password field of a Person object using a setter method, the value of that field will not
 * be included in any JSON representation of the object.

 * If you have a field in your Java class that you want to exclude from serialization or deserialization in JSON,
 * but you still need to set and get its value in your code, you can use a different annotation instead of @JsonIgnore.
 * One option is to use the @JsonProperty annotation with the access parameter set to JsonProperty.Access.WRITE_ONLY.
 * This will indicate to Jackson that the field should only be included during serialization, but not during deserialization*/